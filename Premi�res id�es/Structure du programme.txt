AGRICOLA (lis cette note en pleine écran avec retour automatique à la ligne stp)

LE PROGRAMME : 

Je vois ce genre de programme comme cela (mais c'est peut-être (sûrement) une erreur).
Un programme en fait "assez léger", qui fait appel à des fichiers (en écriture et en lecture).

-Un fichier par joueurs qui récapitule toute ses possessions (nombres de blé, de bois ...), son "plateau de jeu" (non graphique, juste les données, nombre de champs, de clotures...), sa famille (nombre).
-Un fichier "plateau central" qui récapitules toutes les données (nombre de bois sur la case, nombre de moutons sur la case, case utilisée...)

Ces deux fichiers sont sans cesse modifiés et MàJ par les actions des joueurs.
Ils permettent de mettre à jour l'interface graphique du jeu.


-A chaque Action, le joueur provoque une modification de son fichier et du fichier "plateau central" en faisant une action.
-A la fin de chaque action, le programme met à jour l'interface graphique du jeu en fonction des fichiers "individuels" + "plateaux de jeux".
-A la fin de la partie le programme "score" calcule les points en fonction du fichier du joueur.

-A la fin de chaque action, l'interface graphique interroge le fichier du joueur pour se mettre à jour.
-A la fin de chaque action, l'interface graphique du plateau central interroge le fichier "plateau central pour se mettre à jour.

TOUR 1 :

1-Tirage au sort d'une "case plateau aléatoire,
	+ MàJ dans le fichier plateau central,
	+ MàJ de l'interface graphique du fichier "plateau central".

2-Incrémente les cases dans le fichier "plateau central", 
	+ MàJ de l'interface graphique du fichier "plateau central"

3-Calcul le nombre de d'action par joueurs (famille)
	+ MàJ du fichier du joueur ("Nombre d'action" = "nombre de membres de la famille")

4-Actions :									|	
	A-joueur 1 / Action(s) 1,						|	
		+ MàJ fichier du joueur 1 (ressources...),			|	Pour cela je vois bien une grande boucle, 
		+ MàJ fichier du joueur 1 ("Nombre d'action J1"-1)		|	en fait pas trop le choix vu que le nombre d'action dépend
	B-MàJ plateau du joueur 1,						|	de la variable "famille",
	C-Suppression de la "case plateau centrale",				|	Mais j'ai du mal à m'imaginer une boucle avec plusieurs
										|	joueurs de laquelle je puisse "sortir" un joueur :
	D-JoueurX / Action(s) 1,						|	
		+ MàJ fichier du joueur 1,					|	Genre ma boucle commence par une action du le joueur 1, 
	E-MàJ plateau du joueur 1,						|	puis une action du joueur 2, puis une du joueur 1, 
	F-Suppression de la "case plateau centrale",				|	puis une du joueur 2, (ET LA PROBLEME !) il faut sauter le joueur 1
										|	(qui n'à plus d'action) et reprendre la boucle sans lui
	G-Joueur 1 / Action(s) 2,						|	(par exemple s'il reste au joueur 2 d'autres actions). 
		+ MàJ fichier du joueur 1,					|	
	H-MàJ plateau du joueur 1,						|	???
	I-Suppression de la "case plateau centrale"....				|	
										|	
En boucle jusqu'à ce que  "Nombre d'action J1" = 0, "nombre d'action JX" = 0.	|

5-Fin du tour


Le tour fait donc appel à 	-> 3 fonctions,
                           	-> Une grande (grande - grande) boucle (avec moultes fonctions "actions"),
				-> Les fichiers joueurs en lecture et en écriture,
				-> Les fichiers plateaux en lecture et en écriture.
Le tour est lui même compris dans une simple boucle




Première étape (projet) selon moi :
Un "petit" programme qui permet de 
	1-choisir le nombre de joueurs ainsi que la taille de leur famille (une simple fenêtre).
	2-créer en fonction les fichiers joueurs (voir la note fichiers joueurs).
	3-créer un fichier plateau de 10 cases "actions" incrémentables ou non en ressources dont 5 sont cachées et tirées au sort.
	4-créer une interface graphique du plateau de 10 actions (5 + 5 boutons dans une fenêtre).
	5-faire 5 tours de jeu.
	6-Calculer le nombre de ressources collectées par chaque joueur et l'afficher dans une fenêtre.





























